# 15. 디자인 패턴과 프레임워크

## Introduction

- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 방법을 디자인 패턴이라 함
    - 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음
- 프레임워크는 설계와 코드를 함께 재사용하기 위한 것
- 디자인 패턴과 프레임워크 모두 일관성 있는 협력과 관련이 있음

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

- 패턴이란 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어
- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 것
    - Strategy Pattern - '인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임에 알고리즘을 바꿀 수 있게 하자'를 하나의 단어로

### 패턴 분류

- 패턴의 범위나 적용 범위에 따라 아키텍처 패턴 / 분석 패턴 / 디자인 패턴 / 이디엄으로 나뉨
    - 아키텍처 패턴 : 소프트웨어의 전체적인 구조를 결정하기 위해 사용
    - 이디엄 : 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴
    - 분석 패턴 : 다른 패턴들은 주로 기술적인 문제를 해결하는데 초점을 맞추지만, 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춤

### 패턴과 책임-주도 설계

- 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿
    - 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공함
        - STRATEGY 패턴 : 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공
        - BRIDGE 패턴 : 추상화의 조합으로 인해 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만듦
        - OBSERVER 패턴 : 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공
- 특정한 상황에 적용 가능한 패턴을 잘 알고 있으면 책임 주도 설계의 절차를 하나하나 따르지 않고 손쉽게 구성 가능
- 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재함을 암시
    - 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아님
    - 디자인 패턴은 역할과 책임, 협력의 템플릿을 제안할 뿐, 구체적인 구현 방법에 대해서는 제한을 두지 않음

### 캡슐화와 디자인 패턴

- 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있음
- 알고리즘 캡슐화를 인터페이스로 → 영화 예메 시스템의 예제 → STRATEGY 패턴
    - Movie와 DiscountPolicy 사이의 결합도를 낮게 유지할 수 있어 런타임에 알고리즘 변경이 가능
- 알고리즘 캡슐화를 상속으로 → TEMPLATE METHOD 패턴
    - 합성보다는 결합도가 높은 상속을 사용하므로 런타임에 알고리즘 변경이 불가능
    - 알고리즘 교체가 요구사항에 없다면 상대적으로 STRATEGY 패턴보다 복잡도를 낮출 수 있다는 면에서 장점
- 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴 → DECORATOR 패턴
    - 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화
- 대부분의 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것

### 패턴은 출발점이다

- 패턴은 설계의 목표가 되면 안됨. 설계에 이를 수 있는 방향을 제시하는 나침반에 불과
    - 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않으면 그대로 따르지 말고 목적에 맞게 수정하라
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.

## 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

- 디자인 패턴은 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어를 제공하는 것을 목적으로 함
    - 언어에 종속적인 구현코드를 정의하지 않으므로, 매번 구현 코드를 재작성해야함
- 설계를 재사용하면서도 유사한 코드를 반복적으로 구련하는 문제를 피하자 → 프레임워크
- 프레임워크
    - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
    - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격
    - 코드를 재사용함으로써 설계 아이디어를 재사용

## 상위 정책과 하위 정책으로 패키지 분리하기

- 변하는 것과 변하지 않는 것을 분리
    - 변하지 않는 것 : 상위 정책에 속하는 역할들의 협력 구조
    - 변하는 것 : 구체적인 세부 사항
- 프레임워크는 여러 애플리케이션에 걸쳐서 재사용 가능해야하므로 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야 함
- 의존성 역전 우너리에 따라 추상화에만 의존하도록 의존성의 방향을 조정하고, 추상화를 경계로 패키지를 분리하였으므로 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 함
    - 상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에 재사용할 수 있다는 것
    - 재사용 가능한 프레임워크가 만들어진 것

### 제어 역전 원리

- 상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이에 협력 관계를 재사용한다는 것
    - 객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름에서부터 나옴
- 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출함. 따라서 프레임워크로 제어 흐름의 주체가 이동됨 → 제어 역전 원리, 할리우드 원리
    - 과거에는 우리가 직접 라이브러리 코드를 호출했으나, 반대로 된 것